--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         3145728 B, 64 B, 12-way associative
Command:          ./tema2_opt_m input4
Data file:        cachegrind.out.23271
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir             I1mr  ILmr  Dr             D1mr        DLmr        Dw          D1mw      DLmw      
--------------------------------------------------------------------------------
97,313,952,769 1,669 1,655 22,099,351,415 903,047,337 848,995,382 151,073,373 4,421,744 3,975,868  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir             I1mr ILmr Dr            D1mr        DLmr        Dw          D1mw      DLmw       file:function
--------------------------------------------------------------------------------
38,660,320,602   12   12 8,297,089,650  45,455,923  13,443,202 102,400,012         0         0  /home/marius/Desktop/work/an3/asc/tema2/solver_opt.c:mul_sym_block_2
31,820,824,032    6    6 8,192,003,209 512,552,401 512,491,800   2,560,009   379,000   320,001  /home/marius/Desktop/work/an3/asc/tema2/solver_opt.c:mul_sym
19,509,196,832    6    6 4,104,973,613 256,699,819 249,779,786   2,561,609 1,480,087 1,416,964  /home/marius/Desktop/work/an3/asc/tema2/solver_opt.c:mult_mat_trans
 6,977,780,951   19   19 1,390,940,839  87,640,200  72,658,521   6,402,449 1,440,022 1,140,609  /home/marius/Desktop/work/an3/asc/tema2/solver_opt.c:my_solver
   122,410,016    3    3    30,726,400           0           0  11,522,400         0         0  /build/glibc-sMfBJT/glibc-2.31/stdlib/random_r.c:random_r

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/marius/Desktop/work/an3/asc/tema2/solver_opt.c
--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr            D1mr        DLmr        Dw          D1mw      DLmw      

-- line 6 ----------------------------------------
            .    .    .             .           .           .           .         .         .  #include <string.h>
            .    .    .             .           .           .           .         .         .  #include <time.h>
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .  #define max(a, b) (a) > (b) ? a : b;
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .  #define BLOCK_SIZE 40
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .  // Set A = A^t
           10    1    1             0           0           0           8         0         0  void transpose(double *A, int n) {
            .    .    .             .           .           .           .         .         .      register size_t i, j, k;
            .    .    .             .           .           .           .         .         .      // Transpose the blocks that are on the main diagonal
            1    0    0             0           0           0           0         0         0      register size_t i_start = 0;
           10    0    0             1           0           0           0         0         0      register size_t n_blocks = n / BLOCK_SIZE;
            .    .    .             .           .           .           .         .         .      // Iterates though the blocks
          165    1    1             0           0           0           0         0         0      for (k = 0; k < n_blocks; k++) {
        6,600    0    0             0           0           0           0         0         0          for (i = i_start; i < i_start + BLOCK_SIZE; i++) {
       14,400    1    1         3,200           0           0       1,600         0         0              double *A_lin_1 = &A[i*n + (i + 1)];
       14,400    1    1         3,200           0           0       1,600         0         0              double *A_col_1 = &A[(i + 1)*n + i];
      132,800    0    0             0           0           0           0         0         0              for (j = i + 1; j < i_start + BLOCK_SIZE; j++) {
       93,600    0    0        62,400       4,640       4,524      31,200         0         0                  double aux = *A_lin_1;
      124,800    0    0        93,600       4,960       4,836      31,200         0         0                  *A_lin_1 = *A_col_1;
       93,600    0    0        62,400           0           0      31,200         0         0                  *A_col_1 = aux;
            .    .    .             .           .           .           .         .         .  
       31,200    0    0        31,200           0           0           0         0         0                  A_lin_1++;
      124,800    0    0        62,400           0           0           0         0         0                  A_col_1 += n;
            .    .    .             .           .           .           .         .         .              }
            .    .    .             .           .           .           .         .         .          }
           40    0    0             0           0           0           0         0         0          i_start += BLOCK_SIZE;
            .    .    .             .           .           .           .         .         .      }
            .    .    .             .           .           .           .         .         .  
          165    1    1            81           0           0           1         0         0      for (size_t lb = 0; lb < n_blocks; lb++) {
          280    0    0            40           0           0           0         0         0          register size_t j_start = (lb + 1) *  BLOCK_SIZE;
        4,960    0    0            40           0           0           0         0         0          for (register size_t rb = lb + 1; rb < n_blocks; rb++) {
       10,140    1    1         2,340           0           0           0         0         0              register double *A_lin_2 = &A[(lb*BLOCK_SIZE)*n + j_start];
      292,500    1    1        32,760           0           0           0         0         0              for (i = lb*BLOCK_SIZE; i < lb*BLOCK_SIZE + BLOCK_SIZE; i++) {
       31,200    0    0             0           0           0           0         0         0                  register double *A_lin_1 = A_lin_2;//&A[i*n + j_start];
      218,400    1    1        62,400           0           0           0         0         0                  register double *A_col_1 = &A[j_start*n + i];
    5,148,000    0    0             0           0           0           0         0         0                  for (j = j_start; j < j_start + BLOCK_SIZE; j++) {
    2,496,000    0    0     1,248,000     179,400     157,320   1,248,000         0         0                      double aux = *A_lin_1;
    2,496,000    0    0     1,248,000     187,160     157,401   1,248,000         0         0                      *A_lin_1 = *A_col_1;
    2,496,000    0    0     1,248,000           0           0   1,248,000         0         0                      *A_col_1 = aux;
            .    .    .             .           .           .           .         .         .  
    1,248,000    0    0             0           0           0           0         0         0                      A_lin_1++;
    4,992,000    0    0     1,248,000           0           0           0         0         0                      A_col_1 += n;
            .    .    .             .           .           .           .         .         .                  }
      124,800    0    0        31,200           0           0           0         0         0                  A_lin_2 += n;
            .    .    .             .           .           .           .         .         .              }
          780    0    0             0           0           0           0         0         0              j_start += BLOCK_SIZE;
            .    .    .             .           .           .           .         .         .          }
            .    .    .             .           .           .           .         .         .      }
            9    0    0             7           1           1           0         0         0  }
            .    .    .             .           .           .           .         .         .  
           13    2    2             0           0           0          10         0         0  void mul_sym_block_2(double *C, double *A, double *B, int N) {
            .    .    .             .           .           .           .         .         .      register size_t i;
            .    .    .             .           .           .           .         .         .      register size_t j;
            .    .    .             .           .           .           .         .         .      register size_t k;
            2    0    0             1           0           0           0         0         0      register size_t n = N;
            1    0    0             0           0           0           0         0         0      const register size_t block_size = 40;
            .    .    .             .           .           .           .         .         .  
            3    0    0             0           0           0           1         0         0      const register size_t nb = n * block_size;
            .    .    .             .           .           .           .         .         .  
            7    1    1             1           0           0           1         0         0      memset(C, 0, n*n*sizeof(*C));
            1    0    0             1           0           0           0         0         0      register double *C_lin = C;
          245    1    1             0           0           0           0         0         0      for (register size_t bl = 0; bl < n; bl += block_size) {
        9,800    1    1             0           0           0           0         0         0          for (register size_t br = 0; br < n; br += block_size) {
        9,600    1    1         1,600           0           0           0         0         0              register double *A_lin = A + bl * n + br;
            .    .    .             .           .           .           .         .         .              // C_lin = C + bl*n;
      392,000    0    0             0           0           0           0         0         0              for (register size_t bl2 = 0; bl2 < n; bl2 += block_size) {
            .    .    .             .           .           .           .         .         .                  // register double *A_lin = A + bl * n + br;
      448,000    0    0        64,000           0           0           0         0         0                  register double *B_lin = B + bl2 * n + br;
            .    .    .             .           .           .           .         .         .                  // C_lin = C + bl*n + bl2;
   15,680,000    1    1             0           0           0           0         0         0                  for (i = 0; i < block_size; i++) {
            .    .    .             .           .           .           .         .         .                      // register double *B_lin = B + bl2 * n + br;
  627,200,000    2    2             0           0           0           0         0         0                      for (j = 0; j < block_size; j++) {
  204,800,000    0    0             0           0           0           0         0         0                          register double sum1 = 0;
  204,800,000    0    0             0           0           0           0         0         0                          register double sum2 = 0;
  204,800,000    0    0             0           0           0           0         0         0                          register double sum3 = 0;
  204,800,000    0    0             0           0           0           0         0         0                          register double sum4 = 0;
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .                          // A_lin will be A + (i + bl)*n + br
            .    .    .             .           .           .           .         .         .                          // B_lin will be B + (j + bl2)*n + br
6,656,000,000    1    1             0           0           0           0         0         0                          for (k = 0; k < block_size; k += 4) {
5,120,000,000    1    1 2,048,000,000   5,119,961       3,200           0         0         0                              sum1 += *A_lin * (*B_lin);
7,168,000,000    0    0 2,048,000,000           0           0           0         0         0                              sum2 += *(A_lin + 1) * (*(B_lin + 1));
7,168,000,000    0    0 2,048,000,000  25,600,000  13,120,000           0         0         0                              sum3 += *(A_lin + 2) * (*(B_lin + 2));
7,168,000,000    0    0 2,048,000,000           0           0           0         0         0                              sum4 += *(A_lin + 3) * (*(B_lin + 3));
            .    .    .             .           .           .           .         .         .  
1,024,000,000    0    0             0           0           0           0         0         0                              A_lin += 4;
1,024,000,000    0    0             0           0           0           0         0         0                              B_lin += 4;
            .    .    .             .           .           .           .         .         .                          }
  307,200,000    1    1             0           0           0           0         0         0                          A_lin -= block_size;//n;
  409,600,000    0    0             0           0           0           0         0         0                          B_lin += n - block_size;//Weird
1,024,000,000    0    0   102,400,000  14,735,961     320,001 102,400,000         0         0                          *(C_lin) += sum1 + sum2 + sum3 + sum4;
  102,400,000    0    0             0           0           0           0         0         0                          C_lin++;
            .    .    .             .           .           .           .         .         .                      }
   10,240,000    0    0             0           0           0           0         0         0                      C_lin += n - block_size;
   10,240,000    0    0     2,560,000           0           0           0         0         0                      B_lin -= nb;
    5,120,000    0    0             0           0           0           0         0         0                      A_lin += n;
            .    .    .             .           .           .           .         .         .                  }
      256,000    0    0        64,000           0           0           0         0         0                  C_lin -= nb;
      128,000    0    0             0           0           0           0         0         0                  C_lin += block_size;
      192,000    0    0             0           0           0           0         0         0                  A_lin -= nb;
            .    .    .             .           .           .           .         .         .              }
        4,800    0    0             0           0           0           0         0         0              C_lin -= n;
            .    .    .             .           .           .           .         .         .          }
          120    0    0            40           0           0           0         0         0          C_lin += nb;
            .    .    .             .           .           .           .         .         .      }
           10    0    0             7           1           1           0         0         0  }
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .  void mul_sym_block_1(double *C, double *A, double *B, int N) {
            .    .    .             .           .           .           .         .         .      register size_t i;
            .    .    .             .           .           .           .         .         .      register size_t j;
            .    .    .             .           .           .           .         .         .      register size_t k;
            .    .    .             .           .           .           .         .         .      register size_t n = N;
            .    .    .             .           .           .           .         .         .      const register size_t block_size = n / 2;
            .    .    .             .           .           .           .         .         .  
-- line 121 ----------------------------------------
-- line 145 ----------------------------------------
            .    .    .             .           .           .           .         .         .                  B_lin += n - block_size;//Weird
            .    .    .             .           .           .           .         .         .                  C[i*n + j] += sum1 + sum2 + sum3 + sum4;
            .    .    .             .           .           .           .         .         .              }
            .    .    .             .           .           .           .         .         .              A_lin += block_size;
            .    .    .             .           .           .           .         .         .          }
            .    .    .             .           .           .           .         .         .      }
            .    .    .             .           .           .           .         .         .  }
            .    .    .             .           .           .           .         .         .  
           12    2    2             0           0           0           9         0         0  void mul_sym(double *C, register double *A, double *B, int N) {
            .    .    .             .           .           .           .         .         .      register size_t i;
            2    0    0             1           0           0           0         0         0      const register size_t n = N;
            3    0    0             0           0           0           0         0         0      const register size_t nsq = n*n;
            .    .    .             .           .           .           .         .         .  
            1    0    0             0           0           0           0         0         0      register double *A_lin = A;
            1    0    0             1           0           0           0         0         0      register double *C_lin = C;
            .    .    .             .           .           .           .         .         .  
        4,804    1    1             0           0           0           0         0         0      for (i = 0; i < n; i++) {
        1,600    0    0         1,600       1,599       1,599           0         0         0          register double *B_lin = B;
        8,000    0    0         1,600           0           0           0         0         0          register double *B_fin = B + nsq;
    7,686,400    1    1             0           0           0           0         0         0          while (B_lin < B_fin) {
    5,120,000    0    0             0           0           0           0         0         0              register double sum1 = 0;
    5,120,000    0    0             0           0           0           0         0         0              register double sum2 = 0;
    5,120,000    0    0             0           0           0           0         0         0              register double sum3 = 0;
    5,120,000    0    0             0           0           0           0         0         0              register double sum4 = 0;
            .    .    .             .           .           .           .         .         .  
    7,680,000    0    0             0           0           0           0         0         0              register double *A_fin = A_lin + n;
3,082,240,000    1    1             0           0           0           0         0         0              while (A_lin < A_fin) {
5,120,000,000    1    1 2,048,000,000      13,601       7,800           0         0         0                  sum1 += *A_lin * (*B_lin);
7,168,000,000    0    0 2,048,000,000           0           0           0         0         0                  sum2 += *(A_lin + 1) * (*(B_lin + 1));
7,168,000,000    0    0 2,048,000,000 512,537,200 512,482,400           0         0         0                  sum3 += *(A_lin + 2) * (*(B_lin + 2));
7,168,000,000    0    0 2,048,000,000           0           0           0         0         0                  sum4 += *(A_lin + 3) * (*(B_lin + 3));
            .    .    .             .           .           .           .         .         .  
1,024,000,000    0    0             0           0           0           0         0         0                  A_lin += 4;
1,024,000,000    0    0             0           0           0           0         0         0                  B_lin += 4;
            .    .    .             .           .           .           .         .         .              }
    7,680,000    0    0             0           0           0           0         0         0              A_lin -= n;
   20,480,000    0    0             0           0           0   2,560,000   379,000   320,001              *(C_lin) = sum1 + sum2 + sum3 + sum4;
    2,560,000    0    0             0           0           0           0         0         0              C_lin++;
            .    .    .             .           .           .           .         .         .          }
        3,200    0    0             0           0           0           0         0         0          A_lin += n;
            .    .    .             .           .           .           .         .         .      }
            9    0    0             7           1           1           0         0         0  }
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .  void mult_mat_trans_add(double *B, double *A, double *C, size_t n) {
            .    .    .             .           .           .           .         .         .      register size_t i;
            .    .    .             .           .           .           .         .         .      register size_t j;
            .    .    .             .           .           .           .         .         .      const register size_t nsq = n * n;
            .    .    .             .           .           .           .         .         .      register size_t ni = 0;
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .      register double *A_lin_1 = A;
-- line 194 ----------------------------------------
-- line 256 ----------------------------------------
            .    .    .             .           .           .           .         .         .          C_lin += n + 1;
            .    .    .             .           .           .           .         .         .          C_col += n + 1;
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .          ni += n;
            .    .    .             .           .           .           .         .         .      }
            .    .    .             .           .           .           .         .         .  }
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .  // Compute B = A*A^t
           11    1    1             0           0           0           9         0         0  void mult_mat_trans(double *B, double *A, size_t n) {
            .    .    .             .           .           .           .         .         .      register size_t i;
            .    .    .             .           .           .           .         .         .      register size_t j;
            3    0    0             1           0           0           0         0         0      const register size_t nsq = n * n;
            1    1    1             0           0           0           0         0         0      register size_t ni = 0;
            .    .    .             .           .           .           .         .         .  
            1    0    0             1           0           0           0         0         0      register double *A_lin_1 = A;
            1    0    0             1           0           0           0         0         0      register double *A_lin_2 = A;
            1    0    0             1           0           0           0         0         0      register double *B_lin = B;
            1    0    0             1           0           0           0         0         0      register double *B_col = B;
        4,804    1    1         1,601           0           0           0         0         0      for (i = 0; i < n; i++) {
    7,692,800    1    1     1,282,400           0           0           0         0         0          for (j = i; j < n; j++) {
    2,561,600    0    0             0           0           0           0         0         0              register double sum1 = 0;
    2,561,600    0    0             0           0           0           0         0         0              register double sum2 = 0;
    5,123,200    1    1     1,280,800           0           0           0         0         0              register double *A_fin = A_lin_1 + n;
3,079,043,200    1    1             0           0           0           0         0         0              while (A_lin_1 < A_fin) {
6,147,840,000    0    0 2,049,280,000 256,620,218 249,779,613           0         0         0                  sum1 += *A_lin_1 * (*A_lin_2);
8,197,120,000    0    0 2,049,280,000           0           0           0         0         0                  sum2 += *(A_lin_1 + 1) * (*(A_lin_2 + 1));
1,024,640,000    0    0             0           0           0           0         0         0                  A_lin_1 += 2;
1,024,640,000    0    0             0           0           0           0         0         0                  A_lin_2 += 2;
            .    .    .             .           .           .           .         .         .              }
    5,123,200    0    0     1,280,800      79,600         172           0         0         0              A_lin_1 -= n;
    5,123,200    0    0             0           0           0   1,280,800   200,887   161,795              *B_lin = sum1 + sum2;// + C[i*n + j];//*C_lin;
            .    .    .             .           .           .           .         .         .              // The output is symmetrical
    2,561,600    0    0     1,280,800           0           0   1,280,800 1,279,200 1,255,169              *B_col = *B_lin;// + C[j*n + i];//*C_col;
    1,280,800    0    0             0           0           0           0         0         0              B_lin++;
    3,842,400    0    0     1,280,800           0           0           0         0         0              B_col += n;
            .    .    .             .           .           .           .         .         .          }
        4,800    0    0             0           0           0           0         0         0          B_lin += i + 1;
       11,200    0    0         1,600           0           0           0         0         0          B_col += n + 1 - nsq + ni;
            .    .    .             .           .           .           .         .         .  
        4,800    0    0         1,600           0           0           0         0         0          A_lin_1 += n;
        8,000    0    0             0           0           0           0         0         0          A_lin_2 -= nsq - ni;
        4,800    0    0         1,600           0           0           0         0         0          ni += n;
        4,800    0    0         1,600           0           0           0         0         0          A_lin_2 += n;
            .    .    .             .           .           .           .         .         .      }
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .      /*
            .    .    .             .           .           .           .         .         .      A_lin_1 = A;
            .    .    .             .           .           .           .         .         .      A_lin_2 = A;
            .    .    .             .           .           .           .         .         .      B_lin = B;
            .    .    .             .           .           .           .         .         .      B_col = B;
            .    .    .             .           .           .           .         .         .      ni = 0;
-- line 306 ----------------------------------------
-- line 335 ----------------------------------------
            .    .    .             .           .           .           .         .         .          B_col += n + 1 - nsq + ni;
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .          A_lin_1 += n;
            .    .    .             .           .           .           .         .         .          A_lin_2 -= nsq - ni;
            .    .    .             .           .           .           .         .         .          ni += n;
            .    .    .             .           .           .           .         .         .          A_lin_2 += n;
            .    .    .             .           .           .           .         .         .      }
            .    .    .             .           .           .           .         .         .      */
            9    0    0             7           1           1           0         0         0  }
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .  /*
            .    .    .             .           .           .           .         .         .   * Add your optimized implementation here
            .    .    .             .           .           .           .         .         .   */
           12    1    1             0           0           0           9         0         0  double* my_solver(int N, double *A, double* B) {
            2    0    0             0           0           0           1         0         0      printf("OPT SOLVER\n");
            7    1    1             1           0           0           2         0         0      double *C = malloc(N*N * sizeof(*C));
            7    0    0             1           0           0           2         0         0      double *D = malloc(N*N * sizeof(*D));
            2    0    0             1           0           0           0         0         0      register size_t n = N;
            .    .    .             .           .           .           .         .         .      register size_t i;
            .    .    .             .           .           .           .         .         .      register size_t j;
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .      double t1, t2;
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .      // Compute C = A * A^t
            .    .    .             .           .           .           .         .         .      // Knowing A is upper triangular
            3    1    1             0           0           0           2         0         0      t1 = clock();
            .    .    .             .           .           .           .         .         .      // register size_t in = 0;
        4,804    1    1             0           0           0           0         0         0      for (i = 0; i < n; i++) {
    3,848,800    0    0             0           0           0           0         0         0          for (j = i; j < n; j++) {
    3,842,400    0    0             0           0           0           0         0         0              register size_t start = max(i, j);
   10,246,400    0    0     1,280,800           0           0   1,280,800   161,944   161,272              C[i*n + j] = 0;
    2,561,600    1    1             0           0           0           0         0         0              register double sum = 0;
    7,684,800    0    0     1,280,800           0           0           0         0         0              register double *A_lin_1 = &A[i*n + start];
    7,684,800    0    0     1,280,800           0           0           0         0         0              register double *A_lin_2 = &A[j*n + start];
    6,404,000    1    1     1,280,800           0           0           0         0         0              register double *A_fin = &A[i*n + n];
1,371,736,800    0    0             0           0           0           0         0         0              while (A_lin_1 < A_fin) {
            .    .    .             .           .           .           .         .         .              // for (k = start; k < n; k++) {
4,103,683,200    0    0 1,367,894,400  87,000,190  72,018,511           0         0         0                  sum += *A_lin_1 * (*A_lin_2);
  683,947,200    0    0             0           0           0           0         0         0                  A_lin_1++;
  683,947,200    0    0             0           0           0           0         0         0                  A_lin_2++;
            .    .    .             .           .           .           .         .         .              }
   10,246,400    1    1     1,280,800           1           1   1,280,800       286         0              C[i*n + j] = sum;
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .              // The output is symetrical
   17,931,200    0    0     3,842,400           0           0   1,280,800 1,277,786   979,331              C[j*n + i] = C[i*n + j];
            .    .    .             .           .           .           .         .         .          }
            .    .    .             .           .           .           .         .         .          // in += n;
            .    .    .             .           .           .           .         .         .      }
            3    0    0             0           0           0           2         1         1      t2 = clock();
            7    1    1             3           1           1           1         0         0      printf("T1 %f\n", (t2 - t1) / CLOCKS_PER_SEC);
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .      // Compute D = B * C
            .    .    .             .           .           .           .         .         .      // C is symetrical
            3    0    0             0           0           0           2         0         0      t1 = clock();
            6    1    1             3           0           0           1         0         0      mul_sym(D, B, C, n);
            3    0    0             0           0           0           2         1         1      t2 = clock();
            7    1    1             3           1           1           1         0         0      printf("T2 %f\n", (t2 - t1) / CLOCKS_PER_SEC);
            .    .    .             .           .           .           .         .         .  
            3    0    0             0           0           0           2         0         0      t1 = clock();
            6    0    0             3           0           0           1         0         0      mul_sym_block_2(D, B, C, n);
            3    0    0             0           0           0           2         1         1      t2 = clock();
            7    1    1             3           1           1           1         0         0      printf("T_test %f\n", (t2 - t1) / CLOCKS_PER_SEC);
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .      // Tranpose: B = B^t
            3    0    0             0           0           0           2         0         0      t1 = clock();
            5    0    0             1           0           0           1         0         0      transpose(B, n);
            3    1    1             0           0           0           2         1         1      t2 = clock();
            7    0    0             3           1           1           1         0         0      printf("T3 %f\n", (t2 - t1) / CLOCKS_PER_SEC);
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .      // Compute C = B * B^t
            3    1    1             0           0           0           2         0         0      t1 = clock();
            6    0    0             2           0           0           1         0         0      mult_mat_trans(C, B, n);
            3    0    0             0           0           0           2         1         1      t2 = clock();
            7    1    1             3           1           1           1         0         0      printf("T4 %f\n", (t2 - t1) / CLOCKS_PER_SEC);
            .    .    .             .           .           .           .         .         .  
            .    .    .             .           .           .           .         .         .      // Compute C = C + D
            3    0    0             0           0           0           2         0         0      t1 = clock();
        4,804    1    1             0           0           0           0         0         0      for (i = 0; i < n; i++) {
    3,846,400    1    1             0           0           0           0         0         0          for (j = 0; j < n; j += 2) {
   28,160,000    2    2     6,400,000     640,002     640,002   1,280,000         0         0              C[i*n + j] += D[i*n + j];
   32,000,000    0    0     6,400,000           0           0   1,280,000         0         0              C[i*n + j + 1] += D[i*n + j + 1];
            .    .    .             .           .           .           .         .         .          }
            .    .    .             .           .           .           .         .         .      }
            3    0    0             0           0           0           2         1         1      t2 = clock();
            7    1    1             3           1           1           1         0         0      printf("T5 %f\n", (t2 - t1) / CLOCKS_PER_SEC);
            .    .    .             .           .           .           .         .         .  
            3    0    0             1           0           0           1         0         0      free(D);
            .    .    .             .           .           .           .         .         .      
            1    0    0             1           0           0           0         0         0      return C;
            8    0    0             7           1           1           0         0         0  }

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/glibc-sMfBJT/glibc-2.31/stdlib/random_r.c

--------------------------------------------------------------------------------
Ir             I1mr ILmr Dr             D1mr        DLmr        Dw          D1mw      DLmw      
--------------------------------------------------------------------------------
96,988,318,077   51   51 21,990,446,580 902,724,504 848,697,391 117,764,888 3,299,109 2,877,574  events annotated

